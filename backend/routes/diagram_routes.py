from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel, Field
from typing import Dict, Any, List, Optional, Union
import logging
from ai.diagram_generator import DiagramGenerator
from ai.content_validator import validate_content
from utils.auth import get_current_user
from flask import Blueprint, request, jsonify
from utils.common import create_response, validate_request_data

# Initialize the router with the correct prefix
router = APIRouter(prefix="/api", tags=["diagram"])
logger = logging.getLogger(__name__)

# Keep the flask blueprint for backward compatibility
diagram_bp = Blueprint('diagram', __name__, url_prefix='/api/diagram')
diagram_generator = DiagramGenerator()

class MessageContent(BaseModel):
    type: str
    text: Optional[str] = None

class DiagramRequestMessage(BaseModel):
    type: str = "text"
    text: Optional[str] = None

class BoundsModel(BaseModel):
    x: float = 0
    y: float = 0
    w: float = 0
    h: float = 0

class DiagramRequest(BaseModel):
    """
    Request model for diagram generation.
    Can handle both simple prompt strings and complex objects from tldraw/ai
    """
    # Simple prompt case
    prompt: Optional[str] = None
    
    # Complex case - from tldraw/ai
    message: Optional[List[Union[MessageContent, Dict[str, Any]]]] = None
    canvasContent: Optional[Dict[str, Any]] = None
    contextBounds: Optional[BoundsModel] = None
    promptBounds: Optional[BoundsModel] = None
    
    def get_prompt_text(self) -> str:
        """Extract the prompt text from whatever format it was sent in"""
        # If we have a simple prompt string, use it
        if self.prompt:
            return self.prompt
            
        # If we have a message array, extract text from it
        if self.message:
            text_parts = []
            for msg in self.message:
                if isinstance(msg, dict) and msg.get("type") == "text" and msg.get("text"):
                    text_parts.append(msg["text"])
                elif hasattr(msg, "type") and msg.type == "text" and msg.text:
                    text_parts.append(msg.text)
            
            if text_parts:
                return "\n".join(text_parts)
        
        # If we couldn't extract anything useful, raise an error
        raise HTTPException(status_code=400, detail="No valid prompt text found in request")

class DiagramResponse(BaseModel):
    changes: List[Dict[str, Any]]

@router.post("/generate-diagram", response_model=DiagramResponse)
async def create_diagram(request: DiagramRequest, current_user = Depends(get_current_user)):
    try:
        logger.info(f"Received diagram request from user {current_user.email}")
        
        # Extract the prompt text from the request object
        prompt_text = request.get_prompt_text()
        logger.info(f"Processing diagram prompt: {prompt_text[:100]}...")
        
        # Validate content to ensure it doesn't violate policies
        validation_result = validate_content(prompt_text)
        if not validation_result["valid"]:
            logger.warning(f"Content validation failed: {validation_result['reason']}")
            raise HTTPException(status_code=400, detail=f"Content validation failed: {validation_result['reason']}")
        
        # Generate the diagram based on the prompt
        diagram_data = diagram_generator.generate_diagram(prompt_text)
        
        # Convert the diagram data to the changes format expected by tldraw/ai
        # This is critical - tldraw/ai expects an array of changes, not a document object
        changes = convert_diagram_data_to_changes(diagram_data)
        
        return DiagramResponse(changes=changes)
    
    except Exception as e:
        logger.error(f"Error generating diagram: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Error generating diagram: {str(e)}")

def convert_diagram_data_to_changes(diagram_data: Dict[str, Any]) -> List[Dict[str, Any]]:
    """
    Convert diagram data to the changes format expected by tldraw/ai.
    tldraw/ai expects an array of changes, where each change follows a specific format
    based on the operation type (create, update, delete, etc.)
    
    Args:
        diagram_data: The diagram data generated by DiagramGenerator
        
    Returns:
        List of change objects in the format expected by tldraw/ai
    """
    changes = []
    
    # Extract shapes from the diagram data
    try:
        if not diagram_data or 'document' not in diagram_data:
            logger.warning("Invalid diagram data format")
            return changes
            
        document = diagram_data['document']
        current_page_id = document.get('currentPageId', '')
        
        if not current_page_id or 'pages' not in document or current_page_id not in document['pages']:
            logger.warning("Invalid page structure in diagram data")
            return changes
            
        page = document['pages'][current_page_id]
        
        # Add shapes to changes - format them properly for tldraw/ai
        if 'shapes' in page:
            for shape_id, shape_data in page['shapes'].items():
                # Ensure shape ID has the required "shape:" prefix
                if not shape_id.startswith("shape:"):
                    shape_id = f"shape:{shape_id}"
                
                # Create a proper tldraw/ai shape object
                shape = {
                    "id": shape_id,
                    "type": shape_data.get('type', 'geo'),  # Default to geo if type is missing
                    "x": shape_data.get('x', 0),
                    "y": shape_data.get('y', 0),
                    "rotation": shape_data.get('rotation', 0),
                    "isLocked": shape_data.get('isLocked', False),
                    "opacity": shape_data.get('opacity', 1),
                }
                
                # Add width and height if available (needed for some shape types)
                if 'width' in shape_data:
                    shape['props'] = shape['props'] if 'props' in shape else {}
                    shape['props']['w'] = shape_data['width']
                
                if 'height' in shape_data:
                    shape['props'] = shape['props'] if 'props' in shape else {}
                    shape['props']['h'] = shape_data['height']
                
                # Add text content if available
                if 'text' in shape_data:
                    shape['props'] = shape['props'] if 'props' in shape else {}
                    shape['props']['text'] = shape_data['text']
                
                # Add label if available
                if 'label' in shape_data:
                    shape['props'] = shape['props'] if 'props' in shape else {}
                    shape['props']['label'] = shape_data['label']
                
                # Ensure props exists if it doesn't already
                if 'props' not in shape:
                    shape['props'] = {}
                
                # Add any other properties from the original props
                if 'props' in shape_data and isinstance(shape_data['props'], dict):
                    for key, value in shape_data['props'].items():
                        shape['props'][key] = value
                
                # Add parent info if available
                if 'parentId' in shape_data:
                    parent_id = shape_data['parentId']
                    # Also ensure parent ID has the required prefix
                    if not parent_id.startswith("shape:"):
                        parent_id = f"shape:{parent_id}"
                    shape['parentId'] = parent_id
                
                changes.append(shape)
                
        # Add connectors to changes if present
        if 'connectors' in page:
            for connector_id, connector_data in page['connectors'].items():
                # Ensure connector ID has the required "shape:" prefix
                if not connector_id.startswith("shape:"):
                    connector_id = f"shape:{connector_id}"
                
                connector = {
                    "id": connector_id,
                    "type": connector_data.get('type', 'arrow'),  # Default to arrow if type is missing
                    "x": connector_data.get('x', 0),
                    "y": connector_data.get('y', 0),
                    "rotation": connector_data.get('rotation', 0),
                    "isLocked": connector_data.get('isLocked', False),
                    "opacity": connector_data.get('opacity', 1),
                    "props": connector_data.get('props', {})
                }
                
                # Update any shape references in the connector props to have the shape: prefix
                if 'props' in connector and 'start' in connector['props'] and 'boundShapeId' in connector['props']['start']:
                    bound_shape_id = connector['props']['start']['boundShapeId']
                    if not bound_shape_id.startswith("shape:"):
                        connector['props']['start']['boundShapeId'] = f"shape:{bound_shape_id}"
                        
                if 'props' in connector and 'end' in connector['props'] and 'boundShapeId' in connector['props']['end']:
                    bound_shape_id = connector['props']['end']['boundShapeId']
                    if not bound_shape_id.startswith("shape:"):
                        connector['props']['end']['boundShapeId'] = f"shape:{bound_shape_id}"
                
                # Add parent info if available
                if 'parentId' in connector_data:
                    parent_id = connector_data['parentId']
                    # Also ensure parent ID has the required prefix
                    if not parent_id.startswith("shape:"):
                        parent_id = f"shape:{parent_id}"
                    connector['parentId'] = parent_id
                
                changes.append(connector)
    
    except Exception as e:
        logger.error(f"Error converting diagram data to changes: {str(e)}")
    
    return changes

@diagram_bp.route('/generate', methods=['POST'])
def generate_diagram():
    """
    Generate a diagram based on a text prompt.
    
    Request JSON format:
    {
        "prompt": "Text description of the diagram to generate"
    }
    
    Returns:
        JSON response with generated diagram data or error message
    """
    try:
        data = request.get_json()
        
        # Validate request data
        validation_error = validate_request_data(data, ['prompt'])
        if validation_error:
            return jsonify(create_response(False, message=validation_error, status_code=400)), 400
        
        prompt = data['prompt']
        
        # Validate the prompt
        if not diagram_generator.validate_prompt(prompt):
            return jsonify(create_response(
                False, 
                message="Invalid prompt. Please provide a more detailed description.",
                status_code=400
            )), 400
        
        # Generate diagram
        diagram_data = diagram_generator.generate_diagram(prompt)
        
        # Convert to changes for tldraw format
        changes = convert_diagram_data_to_changes(diagram_data)
        
        return jsonify(create_response(
            True,
            data={"changes": changes},
            message="Diagram generated successfully"
        )), 200
        
    except Exception as e:
        logger.error(f"Error generating diagram: {str(e)}")
        return jsonify(create_response(
            False,
            message=f"Error generating diagram: {str(e)}",
            status_code=500
        )), 500

# Add more routes as needed for diagram functionality 